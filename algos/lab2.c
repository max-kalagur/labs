#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#define MAX 1000

int main()
{
// Варіант №4

// Розробити алгоритм і програму дихотомічного пошуку. В якості вихідних даних слід використовувати масив цілих чисел, який формується за допомогою датчика випадкових чисел з діапазоном від 0 до 100. Аргумент пошуку – число.

    srand(time(NULL));

    int *arr = (int*)malloc(MAX * sizeof(int));

    struct timespec start, end;
    int x, m;

    printf("Кількість елементів в масиві (до 1000):\n");
    scanf("%d", &m);
    printf("Шукане значення (від 0 до 100):\n");
    scanf("%d", &x);
    
    for(int z=0; z<5; z++) {

        // Заповнюємо масив arr випадковими числами
        for(int i=0; i<=m; i++) {
            arr[i] = rand() % 100;
        }

        clock_gettime(CLOCK_MONOTONIC_RAW, &start);

        //============================================================/
        // Бінарний пошук
        
        // Сортуєм массив по зростанню
        for(int u = 0; u < m; u++) {
            for(int i = 0; i < m; i++){

                if( arr[i] > arr[i+1] ) {
                    int tmp = arr[i+1];
                    arr[i+1] = arr[i];
                    arr[i] = tmp;
                }
            }
        }
    
        // Виконуєм пошук числа
        int key = -1, c, left = 0, right = m-1;

        while( key == -1 && right-1 != left ) {

            c = (left + right) / 2;

            if( x == arr[c] ) {
                key = c;
            }
            else if( arr[c] > x ) {
                right = c;
            }
            else {
                left = c;
            }
        }

        //
        //
        //
        // Алгоритм є лінійним, тобто, не залажить від значень вихідних данних
        // Асимптотична складність алгоритму: F(n) = 1 + (3+2)*n + n*(1+2 + 1+1 + 1+1 + 2+1) = 1 + 16n → Θ(n)
        // 1 + (3+2)*n + n*(тіло циклу) - складність циклу. (3+2)*n - +2 тому що індексація в умові
        // Тіло циклу:
        // 1+2 - int val = arr[i];
        // 1+1 - if( val % 2 == 0 ) {
        // 1+1 - int len = sizeof(arrOdd) / sizeof(int);
        // 2+1 - arrOdd[len+1] = val;
        // Верхня оцінка складності алгоритму: O(n)
        //=============================================================/

        clock_gettime(CLOCK_MONOTONIC_RAW, &end);
        printf("Time taken for %d items: %lf sec.\n", m, end.tv_sec-start.tv_sec + 0.000000001*(end.tv_nsec-start.tv_nsec));

        if( key == -1 ) {
            printf("Ключ не знайдено\n");
            printf("-------------\n");
        }
        else {
            printf("Ключ: %d. arr[%d] = %d\n",key, key, x);
            printf("-------------\n");
        }
    }

    /* Output:
        Кількість елементів в масиві (до 1000):
        100
        Шукане значення (від 0 до 100):
        15

        Time taken for 100 items: 0.000233 sec.
        Ключ не знайдено
        -------------
        Time taken for 100 items: 0.000219 sec.
        Ключ: 12. arr[12] = 15
        -------------
        Time taken for 100 items: 0.000224 sec.
        Ключ: 23. arr[23] = 15
        -------------
        Time taken for 100 items: 0.000221 sec.
        Ключ не знайдено
        -------------
        Time taken for 100 items: 0.000207 sec.
        Ключ: 10. arr[10] = 15
        -------------

        ////////// Тест на більших числах <<<<<<<<<<<<<<<<<<<<<<<

        Кількість елементів в масиві (до 100000):
        100000
        Шукане значення (від 0 до 100000):
        93175

        Time taken for 100000 items: 44.881605 sec.
        Ключ не знайдено
        -------------
        Time taken for 100000 items: 45.024604 sec.
        Ключ: 93132. arr[93132] = 93175
        -------------
        Time taken for 100000 items: 45.314546 sec.
        Ключ: 93172. arr[93172] = 93175
        -------------
        Time taken for 100000 items: 44.822357 sec.
        Ключ: 93127. arr[93127] = 93175
        -------------
        Time taken for 100000 items: 45.147082 sec.
        Ключ не знайдено
        -------------

        /////////// Сортування і пошук окремо <<<<<<<<<<<<<<<<<<<<<<<

        Кількість елементів в масиві (до 100000):
        100000
        Шукане значення (від 0 до 100000):
        73971

        Time taken for sorting: 45.314998 sec.
        Time taken for searching: 0.000000 sec.
        Ключ: 74255. arr[74255] = 73971
        
    */

    return 0;
}